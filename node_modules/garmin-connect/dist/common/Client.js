"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const qs_1 = __importDefault(require("qs"));
const fs_1 = __importDefault(require("fs"));
const stream_1 = __importDefault(require("stream"));
const util_1 = __importDefault(require("util"));
const path_1 = __importDefault(require("path"));
const pipeline = util_1.default.promisify(stream_1.default.pipeline);
class Client {
    constructor(headers) {
        this.headers = headers || {};
        this.cookies = {};
    }
    setCookie(name, value) {
        this.cookies[name] = value;
        this.headers.Cookie = this.getCookieString();
    }
    parseCookies(response) {
        const setCookies = response && response.headers && response.headers['set-cookie'];
        if (setCookies) {
            setCookies.forEach((c) => {
                const [cookieValue] = c.split(';');
                const [name, value] = cookieValue.split('=');
                this.setCookie(name, value);
            });
        }
        return response;
    }
    getCookie(name) {
        return this.cookies[name];
    }
    getCookieString() {
        return Object.entries(this.cookies)
            .map((e) => `${e[0]}=${e[1]}`)
            .join('; ');
    }
    async post(url, data, params) {
        try {
            const response = await (0, axios_1.default)({
                method: 'POST',
                params,
                url,
                data: qs_1.default.stringify(data),
                headers: {
                    ...this.headers,
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                maxRedirects: 0
            });
            this.parseCookies(response);
            return response.data;
        }
        catch (e) {
            const response = e;
            this.parseCookies(response);
            if (response.status === 302 || response.status === 301) {
                if (response.headers && response.headers.location) {
                    return this.post(response.headers.location, data, params);
                }
            }
            return response.data;
        }
    }
    async postJson(url, data, params, headers = {}) {
        const response = await (0, axios_1.default)({
            method: 'POST',
            params,
            url,
            data: JSON.stringify(data, null, 4),
            headers: {
                ...this.headers,
                ...headers,
                'Content-Type': 'application/json'
            }
        });
        this.parseCookies(response);
        return response.data;
    }
    async postBlob(url, formData, params, headers = {}) {
        const response = await (0, axios_1.default)({
            method: 'POST',
            params,
            url,
            data: formData,
            headers: {
                ...this.headers,
                ...headers,
                ...formData.getHeaders()
            }
        });
        this.parseCookies(response);
        return response.data;
    }
    async putJson(url, data, params) {
        const response = await (0, axios_1.default)({
            method: 'PUT',
            params,
            url,
            data: JSON.stringify(data, null, 4),
            headers: {
                ...this.headers,
                'Content-Type': 'application/json'
            }
        });
        this.parseCookies(response);
        return response.data;
    }
    downloadBlob(downloadDir = '', url, data, params) {
        const queryData = qs_1.default.stringify(data);
        const queryDataString = queryData ? `?${queryData}` : '';
        return (0, axios_1.default)({
            method: 'GET',
            params,
            responseType: 'stream',
            url: `${url}${queryDataString}`,
            headers: this.headers,
            maxRedirects: 0
        })
            .catch((r) => {
            const { response } = r || {};
            const { status, headers } = response || {};
            const { location } = headers || {};
            this.parseCookies(response);
            if (status === 302 || status === 301) {
                if (headers && location) {
                    return this.downloadBlob(downloadDir, location, data, params);
                }
            }
            return r;
        })
            .then((r) => this.parseCookies(r))
            .then(async (r) => {
            const { headers } = r || {};
            const { 'content-disposition': contentDisposition } = headers || {};
            const downloadDirNormalized = path_1.default.normalize(downloadDir);
            if (contentDisposition) {
                const defaultName = `garmin_connect_download_${Date.now()}`;
                const [, fileName = defaultName] = contentDisposition.match(/filename="(.+)"/) || [];
                const filePath = path_1.default.resolve(downloadDir, fileName);
                await pipeline(r.data, fs_1.default.createWriteStream(filePath));
                return filePath;
            }
            throw new Error(`Could not download file ${url} to ${downloadDirNormalized}`);
        });
    }
    get(url, data, params) {
        const queryData = qs_1.default.stringify(data);
        const queryDataString = queryData ? `?${queryData}` : '';
        return (0, axios_1.default)({
            method: 'GET',
            params,
            url: `${url}${queryDataString}`,
            headers: this.headers,
            maxRedirects: 0
        })
            .catch((r) => {
            const { response } = r || {};
            const { status, headers } = response || {};
            const { location } = headers || {};
            this.parseCookies(response);
            if (status === 302 || status === 301) {
                if (headers && location) {
                    return this.get(location, data, params);
                }
            }
            return r;
        })
            .then((r) => this.parseCookies(r))
            .then((r) => {
            if (typeof r === 'string') {
                return r;
            }
            return r && r.data;
        });
    }
}
module.exports = Client;
//# sourceMappingURL=Client.js.map